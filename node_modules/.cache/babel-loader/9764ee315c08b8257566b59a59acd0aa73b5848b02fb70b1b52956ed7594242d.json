{"ast":null,"code":"import { encodeVersion } from \"./encodeVersion.js\";\nimport { getAnalyticsOptions } from \"./getAnalyticsOptions.js\";\nimport { packageVersion } from \"../internal/utils/packageVersion.js\";\nimport { encodeOSVersion } from \"./encodeOSVersion.js\";\n/**\n * @private\n * @description Try to get the node version out of process, if browser just return 0.0.0\n */\nfunction getNodeVersion() {\n  const failedVersion = '0.0.0';\n  if (typeof window !== 'undefined') {\n    return failedVersion;\n  } else {\n    // node env\n    try {\n      return process.versions.node || failedVersion;\n    } catch (e) {\n      return failedVersion;\n    }\n  }\n}\n/**\n * @private\n * @description Ensure that all values ITrackedPropertiesThroughAnalytics are populated.\n * Accept a partial map of values and returns the complete interface of ITrackedPropertiesThroughAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n */\nfunction ensureShapeOfTrackedProperties(trackedAnalytics) {\n  // try to get the process version from node, but if we're on the client return 0.0.0\n  const defaults = {\n    techVersion: getNodeVersion(),\n    sdkCode: 'T',\n    sdkSemver: packageVersion.split('-')[0],\n    product: 'A',\n    osType: 'Z',\n    osVersion: '0.0',\n    responsive: false,\n    placeholder: false,\n    lazyload: false,\n    accessibility: false\n  };\n  if (!trackedAnalytics) {\n    return defaults;\n  } else {\n    return Object.assign(Object.assign({}, defaults), trackedAnalytics);\n  }\n}\n/**\n * @private\n * @description Creates the complete SDK signature by using all the values provided by ITrackedPropertiesThroughAnalytics\n *              Creation of the signature\n *              - Set the AlgoVersion of the encoding, this is an internal letter that represents the version\n *                of our encoding algorithm, it will allow us to perform breaking changes if we'll need them.\n *              - Take the constant SDK code (Arbitrary letter chosen for each SDK, for Base that letter is 'T')\n *                this is used to tell apart which SDK is being tracked.\n *              - Take the {major.minor} versions of the node version (techVersion) (14.2, 16.2 etc.)\n *              - Take the full semver of the SDK you wish to track\n *              - Take the features used(lazy, placeholder etc.) and turn them to a letter (for example accessibility -> D)\n *              - Before appending the string, the Versions must be encoded, see the function `encodeVersion` for more details\n *              - Append all the variables to a single string\n *              - In any case of an error, return the single letter 'E'\n *\n * @return {string} sdkAnalyticsSignature\n */\nexport function getSDKAnalyticsSignature(_trackedAnalytics) {\n  const trackedAnalytics = ensureShapeOfTrackedProperties(_trackedAnalytics);\n  const analyticsOptions = getAnalyticsOptions(trackedAnalytics);\n  try {\n    const twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n    const encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n    const encodedTechVersion = encodeVersion(twoPartVersion);\n    const encodedOSVersion = encodeOSVersion(analyticsOptions.osVersion);\n    const featureCode = analyticsOptions.feature;\n    const SDKCode = analyticsOptions.sdkCode;\n    const {\n      product,\n      osType\n    } = analyticsOptions;\n    const algoVersion = 'D'; // The algo version is determined here, it should not be an argument\n    return `${algoVersion}${product}${SDKCode}${encodedSDKVersion}${encodedTechVersion}${osType}${encodedOSVersion}${featureCode}`;\n  } catch (e) {\n    // Either SDK or Node versions were unparsable\n    return 'E';\n  }\n}\n/**\n * @private\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' | 'x.y' | string} semVerStr\n */\nfunction removePatchFromSemver(semVerStr) {\n  const parts = semVerStr.split('.');\n  return `${parts[0]}.${parts[1]}`;\n}","map":{"version":3,"names":["encodeVersion","getAnalyticsOptions","packageVersion","encodeOSVersion","getNodeVersion","failedVersion","window","process","versions","node","e","ensureShapeOfTrackedProperties","trackedAnalytics","defaults","techVersion","sdkCode","sdkSemver","split","product","osType","osVersion","responsive","placeholder","lazyload","accessibility","Object","assign","getSDKAnalyticsSignature","_trackedAnalytics","analyticsOptions","twoPartVersion","removePatchFromSemver","encodedSDKVersion","encodedTechVersion","encodedOSVersion","featureCode","feature","SDKCode","algoVersion","semVerStr","parts"],"sources":["C:/Users/natno/OneDrive/เดสก์ท็อป/School-Project/ecom-react-natnoppol/node_modules/@cloudinary/url-gen/sdkAnalytics/getSDKAnalyticsSignature.js"],"sourcesContent":["import { encodeVersion } from \"./encodeVersion.js\";\nimport { getAnalyticsOptions } from \"./getAnalyticsOptions.js\";\nimport { packageVersion } from \"../internal/utils/packageVersion.js\";\nimport { encodeOSVersion } from \"./encodeOSVersion.js\";\n/**\n * @private\n * @description Try to get the node version out of process, if browser just return 0.0.0\n */\nfunction getNodeVersion() {\n    const failedVersion = '0.0.0';\n    if (typeof window !== 'undefined') {\n        return failedVersion;\n    }\n    else {\n        // node env\n        try {\n            return process.versions.node || failedVersion;\n        }\n        catch (e) {\n            return failedVersion;\n        }\n    }\n}\n/**\n * @private\n * @description Ensure that all values ITrackedPropertiesThroughAnalytics are populated.\n * Accept a partial map of values and returns the complete interface of ITrackedPropertiesThroughAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n */\nfunction ensureShapeOfTrackedProperties(trackedAnalytics) {\n    // try to get the process version from node, but if we're on the client return 0.0.0\n    const defaults = {\n        techVersion: getNodeVersion(),\n        sdkCode: 'T',\n        sdkSemver: packageVersion.split('-')[0],\n        product: 'A',\n        osType: 'Z',\n        osVersion: '0.0',\n        responsive: false,\n        placeholder: false,\n        lazyload: false,\n        accessibility: false\n    };\n    if (!trackedAnalytics) {\n        return defaults;\n    }\n    else {\n        return Object.assign(Object.assign({}, defaults), trackedAnalytics);\n    }\n}\n/**\n * @private\n * @description Creates the complete SDK signature by using all the values provided by ITrackedPropertiesThroughAnalytics\n *              Creation of the signature\n *              - Set the AlgoVersion of the encoding, this is an internal letter that represents the version\n *                of our encoding algorithm, it will allow us to perform breaking changes if we'll need them.\n *              - Take the constant SDK code (Arbitrary letter chosen for each SDK, for Base that letter is 'T')\n *                this is used to tell apart which SDK is being tracked.\n *              - Take the {major.minor} versions of the node version (techVersion) (14.2, 16.2 etc.)\n *              - Take the full semver of the SDK you wish to track\n *              - Take the features used(lazy, placeholder etc.) and turn them to a letter (for example accessibility -> D)\n *              - Before appending the string, the Versions must be encoded, see the function `encodeVersion` for more details\n *              - Append all the variables to a single string\n *              - In any case of an error, return the single letter 'E'\n *\n * @return {string} sdkAnalyticsSignature\n */\nexport function getSDKAnalyticsSignature(_trackedAnalytics) {\n    const trackedAnalytics = ensureShapeOfTrackedProperties(_trackedAnalytics);\n    const analyticsOptions = getAnalyticsOptions(trackedAnalytics);\n    try {\n        const twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n        const encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n        const encodedTechVersion = encodeVersion(twoPartVersion);\n        const encodedOSVersion = encodeOSVersion(analyticsOptions.osVersion);\n        const featureCode = analyticsOptions.feature;\n        const SDKCode = analyticsOptions.sdkCode;\n        const { product, osType } = analyticsOptions;\n        const algoVersion = 'D'; // The algo version is determined here, it should not be an argument\n        return `${algoVersion}${product}${SDKCode}${encodedSDKVersion}${encodedTechVersion}${osType}${encodedOSVersion}${featureCode}`;\n    }\n    catch (e) {\n        // Either SDK or Node versions were unparsable\n        return 'E';\n    }\n}\n/**\n * @private\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' | 'x.y' | string} semVerStr\n */\nfunction removePatchFromSemver(semVerStr) {\n    const parts = semVerStr.split('.');\n    return `${parts[0]}.${parts[1]}`;\n}\n"],"mappings":"AAAA,SAASA,aAAa,QAAQ,oBAAoB;AAClD,SAASC,mBAAmB,QAAQ,0BAA0B;AAC9D,SAASC,cAAc,QAAQ,qCAAqC;AACpE,SAASC,eAAe,QAAQ,sBAAsB;AACtD;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAAA,EAAG;EACtB,MAAMC,aAAa,GAAG,OAAO;EAC7B,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;IAC/B,OAAOD,aAAa;EACxB,CAAC,MACI;IACD;IACA,IAAI;MACA,OAAOE,OAAO,CAACC,QAAQ,CAACC,IAAI,IAAIJ,aAAa;IACjD,CAAC,CACD,OAAOK,CAAC,EAAE;MACN,OAAOL,aAAa;IACxB;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,8BAA8BA,CAACC,gBAAgB,EAAE;EACtD;EACA,MAAMC,QAAQ,GAAG;IACbC,WAAW,EAAEV,cAAc,CAAC,CAAC;IAC7BW,OAAO,EAAE,GAAG;IACZC,SAAS,EAAEd,cAAc,CAACe,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACvCC,OAAO,EAAE,GAAG;IACZC,MAAM,EAAE,GAAG;IACXC,SAAS,EAAE,KAAK;IAChBC,UAAU,EAAE,KAAK;IACjBC,WAAW,EAAE,KAAK;IAClBC,QAAQ,EAAE,KAAK;IACfC,aAAa,EAAE;EACnB,CAAC;EACD,IAAI,CAACZ,gBAAgB,EAAE;IACnB,OAAOC,QAAQ;EACnB,CAAC,MACI;IACD,OAAOY,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEb,QAAQ,CAAC,EAAED,gBAAgB,CAAC;EACvE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASe,wBAAwBA,CAACC,iBAAiB,EAAE;EACxD,MAAMhB,gBAAgB,GAAGD,8BAA8B,CAACiB,iBAAiB,CAAC;EAC1E,MAAMC,gBAAgB,GAAG5B,mBAAmB,CAACW,gBAAgB,CAAC;EAC9D,IAAI;IACA,MAAMkB,cAAc,GAAGC,qBAAqB,CAACF,gBAAgB,CAACf,WAAW,CAAC;IAC1E,MAAMkB,iBAAiB,GAAGhC,aAAa,CAAC6B,gBAAgB,CAACb,SAAS,CAAC;IACnE,MAAMiB,kBAAkB,GAAGjC,aAAa,CAAC8B,cAAc,CAAC;IACxD,MAAMI,gBAAgB,GAAG/B,eAAe,CAAC0B,gBAAgB,CAACT,SAAS,CAAC;IACpE,MAAMe,WAAW,GAAGN,gBAAgB,CAACO,OAAO;IAC5C,MAAMC,OAAO,GAAGR,gBAAgB,CAACd,OAAO;IACxC,MAAM;MAAEG,OAAO;MAAEC;IAAO,CAAC,GAAGU,gBAAgB;IAC5C,MAAMS,WAAW,GAAG,GAAG,CAAC,CAAC;IACzB,OAAO,GAAGA,WAAW,GAAGpB,OAAO,GAAGmB,OAAO,GAAGL,iBAAiB,GAAGC,kBAAkB,GAAGd,MAAM,GAAGe,gBAAgB,GAAGC,WAAW,EAAE;EAClI,CAAC,CACD,OAAOzB,CAAC,EAAE;IACN;IACA,OAAO,GAAG;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASqB,qBAAqBA,CAACQ,SAAS,EAAE;EACtC,MAAMC,KAAK,GAAGD,SAAS,CAACtB,KAAK,CAAC,GAAG,CAAC;EAClC,OAAO,GAAGuB,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;AACpC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}